# 4. 条件分岐

ある条件が成り立つかどうかによって処理を分けることを **条件分岐** といいます．

Python では、条件分岐には `if` `else` `elif` を使用します．

## [ 1 ] `if` 文

下の擬似コードのように使います．

``` py
if 条件式:
    処理
```

`条件式` が成り立つときにのみ `処理` を実行します．

`if` 文を書く際は、次の 2 点に注意してください．

* 条件式の後にはコロン `:` を書く．
* `処理` の行頭には空白 (インデント) を書く．

条件式は多くの場合、**比較演算子** と **論理演算子** を使って表されます．

### 比較演算子

数字の大小関係などのデータの比較を行いたい場合、比較演算子を使用します．

比較演算子は下表の通りです．

| 演算子     | 意味                    |
| :--------: | :---------------------: |
| `x == y`   | `x` と `y` は等しい     |
| `x != y`   | `x` と `y` は等しくない |
| `x < y`    | `x` は `y` より小さい   |
| `x > y`    | `x` は `y` より大きい   |
| `x <= y`   | `x` は `y` 以下         |
| `x >= y`   | `x` は `y` 以上         |

次のコード 1 を見てみましょう．

#### コード 1

``` py
score = 100
if score >= 90:
    print("あなたの成績はAです．")
```

* 2 行目の `score >= 90` が条件式になります．
* `score` が `90` 以上のときのみ、3 行目が実行されます．

::: tip TIP : bool 型

真 (`True`) または偽 (`False`) の２種類の値をもつデータを bool 型のデータといいます．

`1 < 2`、`2 * 3 == 8` などの条件式は bool 型のデータです．

コード 2 のように bool 型のデータを出力すると、`True` か `False` が出力されます．

#### コード 2

``` py
# 成り立つ (真)
print(1 < 2)

# 成り立たない (偽)
print(2 * 3 == 8)
```

#### 出力 2

``` py
True
False
```

:::

### 論理演算子

複数の条件式を組み合わせたい場合、論理演算子を用います．

論理演算子は下表の通りです．`A`, `B` は条件式です．

| 演算子    | 意味                               |
| :-------: | :--------------------------------: |
| `A and B` | `A` `B` が共に真のとき真           |
| `A or B`  | `A` `B` がいずれか一方が真のとき真 |
| `not A`   | `A` が真ならば偽、偽なら真         |

次のコード 3 を見てみましょう．

#### コード 3

``` py
score = 85
if 80 <= score and score < 90:
    print("あなたの成績はBです．")
```

* 条件式は `80 <= score and score < 90` です．
* `score` が `80` 以上かつ `90` 未満のときのみ、3 行目が実行されます．

::: tip TIP : 比較演算子の連結

Python では比較の条件は連結することができます．

例えば、コード 3 の `80 <= score and score < 90` は `80 <= score < 90` のように<br>
まとめて書くことができます．

プログラミングを始めたばかりの人は、こちらの方が自然に見えるかもしれませんが、
このような書き方はすべてのプログラミング言語で出来るわけではないので注意しましょう．

:::

### インデント

Python では、行頭の空白 (**インデント**) が重要になります．

インデントによって `if` 文の対象となる文が決まります．

コード 4 では、3 ~ 4 行目の先頭にインデントが入っていますが、5 行目には入っていません．

そのため 5 行目の文 `print('CCC')` は `if` 文の影響を受けません．

#### コード 4

``` py
x = 0
if x == 10:
    print('AAA')  # if 文の対象
    print('BBB')  # if 文の対象
print('CCC')      # if 文の対象ではない
```

#### 出力 4

``` out
CCC
```

## [ 2 ] `else` 文

ある条件式が成り立つ場合と成り立たない場合で処理を分けたい場合、`else` 文を使用します．

`else` 文は次のように使用します．

``` py
if 条件式:
    処理 1
else:
    処理 2
```

`条件式` が成り立つとき `処理 1` を実行し、成り立たないとき `処理 2` を実行します．

次のコード 3 では `x` が 0 以上の整数かどうか判定しています．

#### コード 3

``` py
x = int(input())
if x >= 0:
    print('x は 0 以上です．')
else:
    print('x は 0 未満です．')
```

### 練習問題

#### 問題 4-1 : [テスト](https://atcoder.jp/contests/abc034/tasks/abc034_a)

<br>
<details><summary>問題 4-1 の解答</summary><div>

``` py
x, y = map(int, input().split())
if x < y:
    print('Better')
else:
    print('Worse')
```

</div></details>

#### 問題 4-2 : [ReLU](https://atcoder.jp/contests/abc183/tasks/abc183_a)

<br>
<details><summary>問題 4-2 の解答 1</summary><div>

``` py
x = int(input())
if x >= 0:
    print(x)
else:
    print(0)
```

</div></details>

<br>
<details><summary>問題 4-2 の解答 2</summary><div>

`max` 関数を使うと下のコードのようにシンプルに解けます．

`max(a, b)` で `a` と `b` のうち大きい方を取得します．

関連して、`a` と `b` の小さい方を取得するには `min` 関数を使用します．

``` py
x = int(input())
print(max(x, 0))
```

</div></details>

## [ 3 ] `elif` 文

複数の条件分岐を行うとき、`elif` 文を使用します．

`elif` 文は次のように使用します．

``` py
if 条件式 1:
    処理 1
elif 条件式 2:
    処理 2
elif 条件式 3:
    処理 3
else:
    処理 4
```

上のコードは次のような処理をします．

* `条件式 1` が真のとき `処理 1` を実行します．
* `条件式 1` が偽で `条件式 2` が真のとき `処理 2` を実行します．
* `条件式 1` が偽で `条件式 2` が偽で `条件式 3` が真のとき `処理 3` を実行します．
* すべての条件式が偽のとき `処理 4` を実行します．

### 練習問題

#### 問題 4-3: [A±B Problem](https://atcoder.jp/contests/abc016/tasks/abc016_2)

<br>
<details><summary>問題 4-3 の解答</summary><div>

``` py
A, B, C = map(int, input().split())
if A + B == C and A - B == C:
    print('?')
elif A + B == C:
    print('+')
elif A - B == C:
    print('-')
else:
    print('!')
```

* 等しいかどうかは `==` で判定します．`=` と間違えないよう注意しましょう．

</div></details>

## [ 4 ] 入れ子構造

下のように、`if` 文の中にさらに `if` 文を入れることができます．

``` py
if 条件 1:
    if 条件 2:
        処理 1
    else:
        処理 2
else:
    処理 3
```

このような再帰的な構造を **入れ子構造 (ネスト構造)** と言います．
